<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux网络属性配置]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2FLinux%E7%BD%91%E7%BB%9C%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sed]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2Fsed%2F</url>
    <content type="text"><![CDATA[sed命令 文本处理三剑客： 文本过滤：grep，egrep，fgrep 流编辑器，行：sed 文本格式化工具，报告生成器 12345678sed [OPTION]... 'script' [input-file] ...script：地址定界编辑命令常用选项：-n：不输出模式空间中的内容至屏幕-e script，--expression=script：多点编辑-f /PATH/TO/SED_SCRIPT_FILE：每行一个编辑命令-r，--regexp-extended：支持使用扩展正则表达式-i[SUFFIX],--in-place[=SUFFIX]：直接编辑源文件 地址定界 空地址：对全文进行处理 单地址： #：指定行 /pattern/：被模式所匹配到的每一行 地址范围：#.#；#,+#；#,/pat1/；/pat1/,/pat2/；$最后一行 步进：1-2所有奇数行；2-2所有偶数行 编辑命令d：删除 p：显示模式空间中的内容 a \text：在行后面追加文本“text”，支持使用\n实现多行追加 i \text：在行前面插入文本“text”，支持使用\n实现多行插入 c \text：把匹配到的行替换为此处指定的文本“text” w /PATH/TO/SOMEFILE：保存模式空间匹配到的行至指定的文件中 r /PATH/FROM/SOMEFILE：读取指定文件的内容至当前文件被模式匹配到的行后面；文件合并； =：为模式匹配到的行打印行号 !：条件取反：地址定界!编辑命令； s///：查找替换，其分隔符可自行指定，常用的s@@@，s###等 ​ 替换标记： ​ g：全局替换 ​ w /PATH/TO/SOMEFILE：将替换成功的结果保存至指定文件中 ​ p：显示替换成功的行 高级编辑命令h：把模式空间中的内容覆盖至保持空间中 H：把模式空间中的内容追加至保持空间中 g：把保持空间中的内容覆盖至模式空间中 G：把保持空间中的内容追加至模式空间中 x：把模式空间中的内容与保持空间中的内容互换 n：覆盖读取匹配到的行的下一行至模式空间中 N：追加读取匹配到的行的下一行至模式空间中 d：删除模式空间中的行 D：删除多行模式空间中的所有行 示例： 1234567sed -n 'n;p' FILE：显示偶数行sed '1!G;h;$!d' FILE：逆序显示文件的内容sed '$!d' FILE：取出最后一行sed '$!N;$!D' FILE：取出文件后两行sed '/^$/d;G' FILE：删除原有的所有空白行，而后为所有的非空白行后添加一个空白行sed 'n;d' FILE：显示奇数行sed 'G' FILE：在原有的每行后方添加一个空白行]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[yum工具]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2Fyum%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[YUMyum:yellow dog,Yellowdog Update Modifier yum repository：yum repo，存储了众多rpm包，以及相关的元数据文件（放置于特定目录下：repodata） yum客户端配置文件 /etc/yum.comf：为所有仓库提供公共配置 /etc/yum.repos.d/*.repo：为仓库的指向提供配置 仓库的定义123456789[repositoryID]name=Some name for this repositorybaseurl=url://path/to/repositoryenabled=&#123;1|0&#125;gpgcheck=&#123;1|0&#125;gpgkey=URLenablegroups=&#123;1|0&#125;failovermethod=&#123;roundrobin|priority&#125; #默认为：roundrobin，意为随机挑选cost= #默认为1000 yum命令的用法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778yum [options] [command] [package ...] * install package1 [package2] [...] * update [package1] [package2] [...] * update-to [package1] [package2] [...] * update-minimal [package1] [package2] [...] * check-update * upgrade [package1] [package2] [...] * upgrade-to [package1] [package2] [...] * distribution-synchronization [package1] [package2] [...] * remove | erase package1 [package2] [...] * autoremove [package1] [...] * list [...] * info [...] * provides | whatprovides feature1 [feature2] [...] * clean [ packages | metadata | expire-cache | rpmdb | plugins | all ] * makecache [fast] * groups [...] * search string1 [string2] [...] * shell [filename] * resolvedep dep1 [dep2] [...] (maintained for legacy reasons only - use repoquery or yum provides) * localinstall rpmfile1 [rpmfile2] [...] (maintained for legacy reasons only - use install) * localupdate rpmfile1 [rpmfile2] [...] (maintained for legacy reasons only - use update) * reinstall package1 [package2] [...] * downgrade package1 [package2] [...] * deplist package1 [package2] [...] * repolist [all|enabled|disabled] * repoinfo [all|enabled|disabled] * repository-packages &lt;enabled-repoid&gt; &lt;install|remove|remove-or-reinstall|remove-or-distribution-synchronization&gt; [package2] [...] * version [ all | installed | available | group-* | nogroups* | grouplist | groupinfo ] * history [info|list|packages-list|packages-info|summary|addon-info|redo|undo|rollback|new|sync|stats] * load-transaction [txfile] * updateinfo [summary | list | info | remove-pkgs-ts | exclude-updates | exclude-all | check-running-kernel] * fssnapshot [summary | list | have-space | create | delete] * fs [filters | refilter | refilter-cleanup | du] * check * help [command]显示仓库列表repolist [all|enable|disable]显示程序包listyum list [all|glob_exp1] [glob_exp2] [...]yum list &#123;available|installed|updates&#125; [glob_exp1] [...]安装程序包install package1 [package2] [...]reinstall package1 [package2] [...]（重新安装）升级程序包update [package] [package2] [...]downgrade [package] [package2] [...]（降级）卸载程序包remove | erase package1 [package2] [...]查看程序包informationinfo [...]查看指定的特性（可以是某文件）是由哪个程序所提供provides|whatprovides feature1 [feature2] [...]清理本地缓存clean [packages|metadata|expire-cache|rpmdb|plugins|all]构建缓存makecache搜索search string1 [string2] [...] 以指定的关键字搜索程序包名及summary信息查看指定包所依赖的capabilitiesdeplist package1 [package2] [...]查看yum事务历史history [info|list|packages-list|packages-info|summary|addon-info|redo|undo|rollback|new|sync|stats]安装及升级本地程序包 * localinstall rpmfile1 [rpmfile2] [...] (maintained for legacy reasons only - use install) * localupdate rpmfile1 [rpmfile2] [...] (maintained for legacy reasons only - use update)包组管理的相关命令groupinstall group1 [group2] [...]groupupdate group1 [group2] [...]grouplist [hidden] [groupwildcard] [...]groupremove group1 [group2] [...]groupinfo group1 [...] 如何适用光盘当作本地yum仓库 挂载光盘至某目录，例如/media/cdrom #mount -r -t iso9600 /dev/cdrom /media/cdrom 创建配置文件 yum的命令行选项123456--nogpgcheck：禁止进行gpg check-y：自动回答为“yes”-q：静默模式--disablerepo=repoidglob：临时禁用此处指定的repo--enablerepo=repoidglob：临时启用此处指定的repo--noplugins：禁用所有插件 yum的repo配置文件中可用的变量$releasever：当前os的发行版的主版本号 $arch：平台 $basearch：基础平台 $YUM0-$YUM9 http://mirrors.aliyun.com/centos/$releasever/$basearch/os 创建yum仓库 createrepo [options] &lt;directory&gt; 程序包编译安装testapp-VERSION-release.src.rpm –&gt; 安装后，使用rpmbuild命令制作成二进制格式的rpm包，而后再安装 源代码–&gt;预处理–&gt;编译（gcc）–&gt;汇编–&gt;链接–&gt;执行 源代码组织格式： 多文件：文件中的代码之间，很可能存在跨文件依赖关系 c、c++：make（configure–&gt;Makefile.in–&gt;makefile） java：maven 编译安装三步骤： ./configure 通过选项传递参数，指定启用特性、安装路径等，执行时会参考用户的指定以及Makefile.in文件生成makefile 检查依赖到的外部环境 make 根据makefile文件，构建应用程序 make install 开发工具 autoconf：生成configure脚本 automake：生成Makefile.in 编译C源代码前提：提供开发工具及开发环境 开发工具make，gcc等 开发环境：开发库，头文件 glibc：标准库 通过“包组”提供开发组件，Development Tools，Server Platform Development 第一步：configure脚本选项：指定安装位置、指定启用的特性 –help：获取其支持使用的选项 选项分类： 安装路径设定 –prefix=/PATH/TO/SOMEWHERE：指定安装位置，默认为/usr/local/ –sysconfdir=/PATH/TO/SOMEWHERE：配置文件安装位置 System types Optional Features：可选特性 –disable-FEATURE –enable-FEATURE[=ARG] Optional Packages：可选包 –with-PACKAGE[=ARG] –without-PACKAGE 第二步：make第三步：make install安装后的配置 导出二进制程序目录至PATH环境变量中：编辑/etc/profile.d/NAME.sh，export PATH=/PATH/TO/BIN:$PATH 导出库文件路径：编辑/etc/ld.so.conf.d/NAME.conf添加新的库文件所在目录至此文件中；让心态重新生成缓存ldconfig [-v] 导出头文件：基于链接的方式实现，ln -sv 导出帮助手册：编辑/etc/man.config文件，添加一个MANPATH]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux程序包管理]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2FLinux%E7%A8%8B%E5%BA%8F%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux程序包管理API：Application Program Interface ABI：Application Binary Interface 程序包管理器源代码–&gt;目标二进制格式–&gt;组织成为一个或有限几个“包“文件 安装、升级、卸载、查询、校验 程序包管理器debian：dpt，dpkg，”.deb“ redhat：redhat package manager（rpm），”.rpm“ S.u.S.E：rpm，”.rpm“ Gentoo：ports ArchLinux 命名格式源代码：name-VERSION.tar.gz，VERSION：major.minor.release rpm包命名格式：name-VERSION-release.arch.rpm，VERSION：major.minor.release release.arch：rpm包的发行号 archetecture：i386，x64（amd64），ppc，noarch 前端工具：自动解决依赖关系yum：rhel系列系统上rpm包管理器的前端工具 apt-get(apt-cache)：deb包管理器的前端工具 zypper：suse的rpm管理器前端工具 dnf：Fedora 22+系统上rpm包管理器的前端工具 程序包管理器功能：将编译好的应用程序的各组成文件打包成一个或几个程序包文件，从而更方便的实现程序包的安装、升级、卸载、和查询等管理操作 程序包的组成清单（每个程序包都单独实现） 文件清单 安装或卸载时运行的脚本 数据库（公共） 程序包的名称和版本 依赖关系 功能说明 安装生成的各文件的文件路径及校验码信息 等等 /var/lib/rpm 获取程序包的途径 系统发行版的光盘或官方的文件服务器（或镜像站点） 项目的官方站点 第三方组织 Centos系统上rpm命令管理程序包安装、升级、卸载、查询和校验、数据库维护 rpm命令1234567rpm [OPTIONS] [PACKAGE_FILE]安装：-i,--install升级：-U,--update,-F,--freshen卸载：-e,--erase查询：-q,--query校验：-V,--verify数据库维护：--builddb,--initdb 安装12345678910111213rpm &#123;-i|--install&#125; [install-options] PACKAGE_FILE ...rpm -ivh PACKAGE_FILE ...GENERAL OPTIONS:-v:verbose,详细信息-vv：更详细的输出[install-options]:四类：--noscripts preinstall：安装过程开始之前运行的脚本，%pre，--nopre postinstall：安装过程完成之后运行的脚本，%post，--nopost preuninstall：卸载过程真正开始执行之前运行的脚本，%preun，--nopreun postuninstall：卸载过程完成之后运行的脚本，%postun，--nopostun--nosignature：不检查包签名信息，不检查来源合法性--nodigest：不检查包完整性信息 升级12345678rpm &#123;-U|--upgrade&#125; [install-options] PACKAGE_FILE ...rpm &#123;-F|--freshen&#125; [install-options] PACKAGE_FILE ...-U:升级或安装-F：升级rpm -Uvh PACKAGE_FILE ...rpm -Fvh PACKAGE_FILE ...--oldpackage:降级--force：强制升级 注意 不要对内核做升级操作；Linux支持多内核版本并存，因此，直接安装新版本内核 如果某原程序包的配置文件安装后曾被修改过，升级时，新版本的程序提供的同一个配置文件不会覆盖原有版本的配置文件，而是把新版本的配置文件重命名（FILENAME.rpmnew）后提供 卸载1234rpm &#123;-e|--erase&#125; [--allmatches] [--nodeps] [--noscripts] [--test] PACKAGE_FILE ...--allmatches：卸载所有匹配指定名称的程序包的各版本--nodeps：忽略依赖关系--test：测试卸载，dry run模式 查询1234567891011121314151617181920rpm &#123;-q|--qurey&#125; [select-options] [query-options][select-options]PACKAGE_NAME：查询指定的程序包是否已经安装，极其版本-a，--all：查询所有已经安装过的包-f FILE：查询指定的文件由哪个程序包安装生成-p,--package PACKAGE_FILE：用于实现对未安装的程序包执行查询操作--whatprovides CAPABILITY：查询指定的CAPABILITY由哪个程序包提供--whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖[query-options]--changelog：查询rpm包的changlog-l，--list：程序安装生成的所有文件列表-i，--info：程序包相关的信息，版本号、大小、所属的包组，等；-c，--configfiles：查询指定的程序包提供的配置文件-d，--docfiles：查询指定的程序包提供的文档--provides：列出指定的程序包提供的所有的CAPABILITY-R，--requires：查询指定的程序包的依赖关系--scripts：查看程序包自带的脚本片段用法：-q|PACKAGE, -qf FILE, -qc PACKAGE, -ql PACKAGE, -qd PACKAGE-qp| PACKAGE_FILE, -qpl PACKAGE_FILE, -qpc PACKAGE_FILE,... 校验12345678910rpm &#123;-V|--verify&#125; [select-options] [verify-options]S file size differsM Mode differs (includes permissions and file type)5 digest (formerly MD5 sum) differsD Device major/minor number mismatchL readLink(2) path mismatchU User ownership differsG Group ownership differsT mTime differsP caPabilities differ 包来源合法性验证和完整性验证来源合法性验证完整性验证：输入并导出信任的包制作者的密钥： 对于centos发行版来说 ：rpm – import /etc/pkl/rpm-gpg/RPM-GPG-KEY-Centos-7 验证： 安装此组织签名的程序时，会自动执行验证 手动验证：rpm -K PACKAGE——FILE 数据库重建rpm管理器数据库路径：/var/lib/rpm/ 查询操作：通过此处的数据库进行 获取帮助 Centos7 ：man rpmdb 123rpm &#123;--initdb|--rebuilddb&#125; [--dbpath DIRECTORY] [--root DIRECTORY]--initdb：初始化数据库，当前无任何数据库可初始化创建一个新的，当前有数据库时不执行任何操作--rebuilddb：重新构建，通过读取当前系统上所有已经安装过的程序包进行重新创建]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux任务计划]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2FLinux%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[Linux任务计划、周期性执未来的某时间点执行一次某任务：at batch 周期性运行某任务crontab ​ 执行结果会通过邮件发送给用户 netstat -tnlp 检查本地邮件服务是否开启 本地电子邮件服务smtp：simple mail transmission protocol pop3：post office protocol imap4：Internet Mail Access Protocol mail命令mailx - send and receive Internet mail MUA：Mail User Agent，用户收发邮件的工具程序 12345mailx [-s 'SUBJECT'] username[@hostname]邮件正文的生成：1.交互式输入：‘.’单独成行可以表示正文结束；Ctrl+d提交亦可2.通过输入重定向3.通过管道 at命令1234567891011at [OPTION]... TIMETIME的表示方式 HH:MM [YYYY-mm-dd] noon，midnight，teatime，tomorrow now+(minutes,hours,days,days,weeks)at的作业有队列，用单个字母表示，默认都使用a队列常用选项-l：查看作业队列，相当于atq-f /PATH/FROM/SOMEFILE：从指定文件中读取作业任务，而不用再交互式输入-d：删除指定的作业，相当于atrm-c：查看指定作业的具体内容-q QUEUE：指明队列 注意：作业执行结果是以邮件发送给提交作业的用户 batch命令 batch会让系统自行选择再系统资源较空闲的时间去执行指定的任务 周期性任务计划：cron服务程序cronle：主程序包，提供了crond守护进程及相关辅助工具 确保crond守护进程（daemon） systemctl status crond.service ​ Active:active (running) … … 向crond提交作业的方式不同于at，它需要使用专用的配置文件，此文件有固定格式，不建议使用文本编辑器直接编辑此文件；要使用crontab命令 cron任务分为两类 系统cron任务：主要用于实现系统自身的维护 手动编辑：/etc/crontab文件 用户cron任务 命令：crontab命令 系统cron的配置格式/etc/crontab 1234567891011121314151617181920SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed1.每一行定义一个周期性任务，共7个字段 * * * * *：定义周期性时间 user-name：运行任务的用户身份 command to be executed：任务2.此处的环境变量不同于用户登录后获得的环境，因此，建议命令使用绝对路径，或者自定义PATH环境变量3.执行结果邮件发送给MAILTO指定用户 用户cron的配置格式/var/spool/cron/USERNAME 1234567891011121314151617SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * command to be executed1.每行定义一个cron任务，共6个字段2.此处的环境变量不同于用户登录后获得的环境，因此，建议命令使用绝对路径，或者自定义PATH环境变量3.邮件发送给当前用户 时间表示法： 特定值：给定时间点有效取值范围内的值（ps：day of week和day of mounth一般不同时使用） *：给定时间点上有效取值范围内的所有值，表示“每..” 离散取值：再时间点上使用逗号分隔的多个值 #,#,# 连续取值：在时间点上使用“-”连接开头和结束 #-# 在指定时间点上，定义步长，/#，#表示步长 指定的时间点不能被步长整除时，其意义将不复存在 最小时间单位为“分钟”，想完成“秒”级任务，需要额外借助于其他机制，定义成每分钟任务，利用脚本实现在每分钟之内，循环执行多次 示例： 3 * * * *：每小时第3分钟执行一次 3 4 * * 5：每周五4点3分执行一次 5 6 7 * *：每月7号6点5分执行一次 7 8 9 10 *：每年10月9号8点7分执行一次 9 8 * * 3,7：每周三和周日8点9分各执行一次 0 8,20 * * 3,7：每周三和周日的早八点和晚八点各执行一次 0 9-18 * * 1-5：周一到周五每天9点到18点每小时都执行一次 */5 * * * *：每5分钟执行一次 crontab命令123456crontab [-u user] [-l|-r|-e] [-i] [-s]-e：编辑任务-l：列出所有任务-r：移除所有任务，即删除/var/spool/cron/USERNAME文件-i：在使用-r选项移除所有任务时提示用户确认-u user：root用户可为指定用户管理cron任务 运行结果以邮件通知给当前用户，如果用户拒绝接收邮件 COMMAND &gt; /dev/null COMMAND &amp;&gt; /dev/null 定义COMMAND时，如果命令需要用到%，需要对其转义；放置于单引号中的%不用转义]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bash脚本编程之用户交互]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2Fbash%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[bash脚本编程之用户交互用户交互 read用户交互：通过键盘输入数据，从而完成变量赋值操作 123read [OPTION]... [name...]-p 'PROMPT'-t TIMEOUT bash -n /path/to/some_script 检查脚本中的语法错误 bash -x /path/to/some_script 调试执行]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux压缩工具]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2FLinux%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[压缩和解压缩工具压缩比目的：时间 换 空间；CPU的时间–&gt;磁盘空间 压缩工具compress/uncompress，.z gzip/gunzip，.gz bzip2/bunzip2，.bz2 xz/unxz，.xz zip/unzip lzma/unlzma，.lzma tar，cpio gzip/gunzip/zcat12345gzip [OPTION]... FILE..-d：压缩前，相当于gunzip-#：指定压缩比，默认是6；数字越大压缩比越大（1-9）-c：将压缩结果输出至标准输出gzip -c FILE &gt; /PATH/TO/SOMEFILE.gz bzip2/bunzip2/bzact1234bzip2 [OPTION]...FILE...-d：解压缩-#：指定压缩比，默认是6；数字越大压缩比越大（1-9）-k：keep，保留文件 xz/unxz/xzcat1234xz [OPTION]...FILE...-d：解压缩-#：指定压缩比，默认是6；数字越大压缩比越大（1-9）-k：保留源文件 归档：tar，cpiotar命令1234tar [OPTION]... FILE...创建归档 -cf /PATH/TO/SOMEFILE.tar FILE...展开归档 -xf /PATH/TO/SOMEFILE.tar查看归档文件的文件列表 -tf /PATH/TO/SOMEFILE.tar 归档完成后通常需要压缩，结果此前的压缩工具，就能实现压缩多个文件了 1234567891011归档压缩-z：gzip2-zcf /PATH/TO/SOMEFILE.tar.gz FILE...解压缩并展开归档-zxf /PATH/TO/SOMEFILE.tar.gz-j：bzip2 -jcf -jxf-J：xz -Jcf -Jxf ZIPzip/unzip 后缀名：.zip]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[btrfs文件系统管理]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2Fbtrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[btrfs文件系统核心特性 多物理卷支持：btrfs可由多个底层物理卷组成；支持RAID，以联机“添加”、“移除”、“修改”； 写时复制更新机制（CoW）：复制、更新、及替换指针，而非“就地”更新 自卷：sub_volume 快照：支持快照的快照 透明压缩 文件系统创建123456789101112mkfs.btrfs-L 'LABEL'-d &lt;type&gt;：raid0,raid1,raid5,raid6,raid10,single-m &lt;profile&gt;：raid0,raid1,raid5,raid6,raid10,single，dup-O &lt;feature&gt; -O list-all：列出支持的所有feature属性查看：btrfs filesystem show挂载文件系统：mount -t btrfs /dev/sdb MOUNT_POINT透明压缩机制：mount -o compress=&#123;lzo|zlib&#125; DEVICE_POINT]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[持续更新中。。。 标题一标题二标题三标题四标题五标题六1这是一个bash 外链: Writing 斜体粗体加粗斜体删除线 文字引用 行内代码 ​123多行代码多行代码​ $$数学公式$$ 分割线方法一：— 方法二：+++ 方法三：*** 列表 有序列表项 无序列表项 无序列表项 无序列表项 表格表头1|表头2-|-|-内容11|内容12内容21|内容22 图片]]></content>
  </entry>
  <entry>
    <title><![CDATA[LVM2]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2FLVM2%2F</url>
    <content type="text"><![CDATA[LVM2LVM:logical Volume Manager,Version:2 dm:device mapper,将一个或多个底层块设备组织成一个逻辑设备的模块 /dev/dm-# /dev/mapper/VG_NAME-LV_NAME ​ /dev/mapper/vo10-root /dev/VG_NAME/LV_NAME ​ /dev/vo10/root pv管理工具 pvs：简要pv信息显示 pvdisplay：显示pv的详细信息 pvcreate：/dev/DEVICE：创建pv pvremove vg管理工具 vgs vgdisplay vgcreat vgextend vgreduce vgremove 先做pvmove lv管理工具 lvs lvdisplay lvcreate -L #[大小mMgGtT] -n NAME VolumeGroup lvremove 扩展逻辑卷 lvextend -L [+]#[mMgGtT] /dev/VG_NAME/LV_NAME resize2fs /dev/VG_NAME/LV_NAME 缩减逻辑卷 umount /dev/VG_NAME/LV_NAME e2fsck -f /dev/VG_NAME/LV_NAME resize2fs /dev/VG_NAME/LV_NAME lvreduce -L [-]#[mMgGtT] /dev/VG_NAME/LV_NAME mount 快照：snapshotlvcreat -L #[mMgGtT] -p r -s snapshot_lv_name original_lv_name 文件系统挂载使用挂载光盘设备： 光盘设备文件 IDE：/dev/hdc SATA：/dev/sr0 符号链接文件 /dev/cdrom /dev/cdrw /dev/dvd /dev/dvdrw 12mount -r /dev/cdrom /media/cdromumount /dev/cdrom dd命令convent and copy a file 用法： 123dd if=/PATH/FROM/SRC of=/PATH/TO/DESTbs=#：block size ，复制单元大小count=#：复制多少个bs 磁盘拷贝： dd if=/dev/sda of=/dev/sdb 备份MBR dd if=/dev/sda of=/tmp/mbr.bak bs=256 count=1 破坏MBR中的bootloader： dd if=/dev/zero of=/dev/sda bs=256 count=1 两个特殊设备： /dev/null：数据黑洞 /dev/zero：吐零机]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RAID]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2FRAID%2F</url>
    <content type="text"><![CDATA[RAIDRAID-0 条带卷 strip 读、写性能提升 可用空间：N*min(s1,s2,…) 无容错能力 最少磁盘数：2,2+ RAID-1 镜像卷 mirror 读性能提升、写性能略有下降 可用空间：1*min(s1,s2,…) 有冗余能力 最少磁盘数：2,2+ RAID-4：数据，数据，校验（异或校验）1101,0110,1011 RAID-5 读，写性能提升 可用空间：（N-1）*min（s1,s2,…） 有容错能力 最少磁盘数：3,3+ RAID-6 读，写性能提升 可用空间：（N-2）*min（s1，s2，…） 有容错能力：2块磁盘 最少磁盘数：4,4+ RAID-10 读，写性能提升 可用空间：N*min（s1，s2，….）/2 有容错能力：每组镜像最多只能坏1块 最少磁盘数：4,4+ JBOD Just a Bunch Of Disks 功能：将多块磁盘的空间合并一个大的连续空间使用 可用空间：sum（s1，s2，….） 常见级别：RAID-0，RAID-1，RAID-5，RAID-10，RAID-50，JBOD]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[shell脚本编程]]></title>
    <url>%2Fshell%E8%84%9A%E6%9C%AC%2Fshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[bash脚本编程脚本文件格式第一行 1#!/bin/bash 注释信息：#代码注释缩进，适度添加空白行 语言编程语法格式，库，算法和数据结构编程思想：问题空间–&gt;解空间 变量 局部变量 本地变量 环境变量 位置参数变量 特殊变量 数据类型字符型、数值型弱类型：字符型 算数运算let VAR=expression VAR=$[expression] VAR=$((exptession)) VAR=$(expr argu1 argu2 argu3)注意：有些时候乘法符号需要转义 增强型赋值变量做某种算数运算后回存至此变量中 123let i=$i+nlet i+=n+=,-=,*=,/=,%= 自增 123VAR=$[$VAR+1]let VAR+=1let VAR++ 自减 123VAR=$[$VAR-1]let VAR-=1let VAR-- 条件测试判断某需求是否满足，需要由测试机制来实现如何编写测试表达式以实现所需的测试 执行命令，并利用命令状态返回值来判断 0：成功 1-255：失败 测试表达式 test EXPRESSION [ EXPRESSION ] [[ EXPRESSION ]]注意：EXPRESSION两端必须有空白字符，否则为语法错误 bash的测试类型 数值测试：数值比较 123456-eq：是否等于；[ &amp;num1 -eq $num2 ]-ne：是否不等于-gt：是否大于-ge：是否大于等于-lt：是否小于-le：是否小于等于 字符串测试 12345678==：是否等于&gt;：是否大于&lt;：是否小于!=：是否不等于=~：左侧的字符串是否能够被右侧的PATTERN所匹配-z &quot;STRING&quot;：判断指定的字串是否为空；空则为真，不空为假-n &quot;STRING&quot;：判断指定的字符串是否不空；不空则真，空则为假注意：字符串要加引号，要使用[[]] 文件测试 12345678910111213141516171819202122232425262728293031存在性测试 -a FILE -e FILE存在为真，否则为假 存在性及类型测试 -b FILE：是否存在并且为块设备文件 -c FILE：是否存在并且为字符设备文件 -d FILE：是否存在并且为目录文件 -f FILE：是否存在并且为普通文件 -h FILE或-L FILE：是否存在并且为符号链接文件 -p FILE：是否存在且为命名管道文件 -S FILE：是否存在且为套接字文件 文件权限测试 -r FILE：是否存在并且对当前用户可读 -w FILE：是否存在并且对当前用户可写 -x FILE：是否存在并且对当前用户可执行 特殊权限测试 -u FILE：是否存在并且拥有suid权限 -g FILE：是否存在并且拥有sgid权限 -k FILE：是否存在并且拥有sticky权限 文件是否有内容 -s FILE：是否有内容 时间戳： -N FILE：文件自从上一次读操作后是否被修改过 从属关系测试 -O FILE：当前用户是否为文件是属主 -G FILE：当前用户是否属于文件的属组 双目测试 FILE1 -ef FILE2：FILE1与FILE2是否为指向同一个文件系统的相同Inode的硬链接 FILE1 -nt FILE2：FILE1是否新于FILE2 FILE1 -ot FILE2：FILE1是否旧于FILE2 组合测试条件 逻辑运算 12345第一种方式COMMAND1 &amp;&amp; COMMAND2COMMAND1 || COMMAND2! COMMAND[ -O FILE ] &amp;&amp; [ -r FILE ] 12345第二种方式EXPRESSION1 -a EXPRESSION2EXPRESSION1 -o EXPERSSION2! EXPRESSION[ -O FILE -a -x FILE ] 脚本的状态返回值默认是脚本中执行的最后一条命令的状态返回值自定义状态退出状态码 exit [n]：n为自己指定的状态码主意：shell进程遇到exit时，即会终止，因此，整个脚本执行即为结束 向脚本传递参数位置参数变量1234myscript.sh argu1 argu2引用方式：$1，$2，...，$&#123;10&#125;，$&#123;11&#125;...轮替：shift [n] ：位置参数轮替 特殊变量1234$0：脚本文件路径本身$#：脚本参数的个数$*：所有参数$@：所有参数 过程编程语言的代码执行程序 顺序执行：逐条运行 选择执行 代码有一个分支：条件满足时才会执行 两个或以上的分支：只会执行其中一个满足条件的分支 循环执行： 代码片段（循环体）要执行0、1或多个来回 选择执行 单分支的if语句 123if 测试条件;then 代码分支fi 双分支的if语句 12345if 测试条件;then 条件为真时执行的分支else 条件为假时执行的分支fi - 多分支的if语句 1234567891011if 测试条件1;then 条件为真时执行的分支elif 测试条件2;then 条件为真时执行的分支elif 测试条件3;then 条件为真时执行的分支...elif 测试条件n;then 条件为真时执行的分支fi注意：即便多个条件可能同时满足，分支只会执行其中一个，首先测试为“真”循环执行将一段代码重复执行0、1或多次 进入条件：条件满足时才进入循环 退出条件：每个循环都应该有退出条件，以有机会退出循环 bash脚本： for循环 while循环 until循环 for循环两种格式 遍历列表 控制变量 遍历列表 123for VARAIBLE in LIST;do循环体done 进入条件：只要列表有元素，即可进入循环 退出条件：列表中的元素遍历完成 LIST的生成方式 直接给出 整数列表 {start..end} seq [start [incremtal]] last 返回列表的命令 glob 变量引用：$@]]></content>
      <categories>
        <category>shell脚本</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux磁盘及文件系统管理]]></title>
    <url>%2FLinux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%2F%E7%A3%81%E7%9B%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Linux的哲学思想：一切皆文件设备类型块（block）：随机访问，数据交换单位是“块”字符（character）：线性访问，数据交换单位是“字符” 设备文件：FHS/dev设备文件：关联至设备的驱动程序；设备的访问入口设备号： major：主设备好，区分设备类型，用于标明设备所需要的驱动程序 minor：次设备号，区分同种类型下的不同的设备；是特定设备的访问入口 mknod命令 make block or character special files 12mknod [OPTION]... NAME TYPE [MAJOR MINOR]-m MODE ：创建后的设备文件的访问权限 设备文件名：ICANN磁盘 IDE：/dev/hd[a-z] 例如：/dev/hda,/dev/hdb SCSI,SATA,USB,SAS：/dev/sd[a-z] 分区：/dev/sda#注意：Centos 6和7统统将硬盘设备文件标识为/dev/sd[a-z]# 引用设备的方式 设备文件名 卷标 UUID 磁盘分区：MBR，GPTMBR：Master Boot Record分为三部分 446bytes：bootloader，程序，引导启动操作系统的程序 64bytes：分区表，每16bytes标识一个分区，一共只能有4个分区 4主分区 3主1扩展，n逻辑分区 2bytes：MBR区域的有效性标识：55AA为有效主分区和扩展分区标识[1-4]逻辑分区：[5+] fdisk命令 查看磁盘的分区信息 1fdisk -l [-u] [device...] ：列出指定磁盘设备上的分区情况 管理分区 1fdisk device fdisk提供了一个交互式接口来管理分区，它有许多子命令，分别用于不同的管理功能；所有的操作均在内存中完成，没有直接同步到磁盘；直到使用w命令保存至磁盘上 常用命令 n：创建新分区 d：删除已有分区 t：修改分区类型 l：查看所有已知ID w：保存并退出 q：不保存并退出 m：查看帮助信息 p：显示现有分区信息 注意：在已经分区并且已经挂载其中某个分区的磁盘设备上创建的新分区，内核可能在创建完成后无法直接识别查看系统识别到的分区： 1cat /proc/partitons 通知内核强制重读磁盘分区表 12partx -a [device]kpartx -af [device] 分区创建工具：parted，sfdisk 创建文件系统格式化：低级格式化（分区之前进行，划分磁道）、高级格式化（分区之后对分区进行创建文件系统） 元数据区文件元数据inode（index node）：大小、权限、属主属组、时间戳、数据块指针 符号链接文件：存储数据指针的空间当中存储的是真实文件的访问路径；设备文件：存储数据指针空间当中存储的是设备号（major，minor）bitmap index：位图索引 VFS：Virtual File System Linux的文件系统：ext2(无日志功能)，ext3，ext4，xfs，reiserfs，btrfs 光盘：iso9660 网络文件系统：nfs，cifs 集群文件系统：gfs2，ocfs2 内核级分布式文件系统：ceph windows的文件系统：vfat，ntfs 伪文件系统：proc，sysfs，tmpfs，hugepagefs Unix的文件系统：UFS，FFS，JFS 交换文件系统：swap 用户空间的分布式文件系统：mogilefs，moosefs，glusterfs 文件系统管理工具 创建文件系统工具 mkfs：mkfs.ext2,mkfs.ext3,mkfs.ext4,mkfs.xfs,mkfs.vfat,… 检测及修复文件系统的工具 fsck：fsck.ext2,fsck.ext3,… 查看其属性的工具 dumpe2fs,tune2fs 调整文件系统特征 tune2fs 链接文件：访问同一个文件不同路径 硬链接：指向同一个inode的多个文件路径 特性 目录不支持硬链接 硬链接不能跨文件系统 创建硬链接会增加inode引用计数1ln src link_file 符号链接：指向一个文件路径的另一个文件路径 特性 符号链接与文件是两个各自独立的文件，各有自己的inode，对源文件创建符号链接不会增加引用计数 支持对目录创建符号链接，可以跨文件系统 删除符号链接不影响源文件，但删除源文件，符号指定的路径即不存在，此时会变成无效链接 符号链接文件的大小是其指定文件的路径字符串的字节数1ln -s src link_file 磁盘和文件系统管理内核文件系统的组成部分 文件系统驱动：由内核提供 文件系统管理工具：由用户空间的应用程序提供 ext系列文件系统的管理工具1mkfs.ext2,mkfs.ext3,mkfs.ext4 mkfs -t ext2=mkfs.ext2 ext系列文件系统专用管理工具：mke2fs 1234567891011mke2fs [OPTIONS] device -t &#123;ext2|ext3|ext4&#125;：指明要创建的文件系统类型 mkfs.ext4=mkfs -t ext4=mke2fs -t ext4 -b &#123;1024|2048|4096&#125;：指明文件系统的块大小 -L LABEL：指明卷标 -j ：创建有日志功能的文件系统ext3 mke2fs -j=mke2fs -t ext3=mkfs -t ext3=mkfs.ext3 -i N：bytes-per-inode，指明inode与字节的比率；即每多少字节创建一个Inode -N N：直接指明要给此文件系统创建的inode的数量 -m N：指定预留的空间，百分比 -O [^]FEATURE ：以指定的特性创建目标文件系统 e2label命令：卷标的查看与设定 查看：e2label device 设定：e2label device LABEL tune2fs命令：查看或修改ext系列文件系统的某些属性adjust tunable filesystem paramenters on ext2/ext3/ext4 filesystems注意：块大小创建后不可修改 12345678910tune2fs [OPTIONS] device-l：查看超级块的内容修改制定文件系统的属性-j：ext2--&gt;ext3-L LABEL：修改卷标-m N ：调整预留空间百分比-O [^]FEATHER：开启或关闭某种特性-o [^]mount_options：开启或关闭某种默认挂载选项 acl ^acl dempe2fs命令：显示ext系列文件系统的属性信息 1dumpe2fs [-h] device 用户实现文件系统检测的工具因进程意外终止或系统崩溃等原因导致定稿操作非正常终止时，可能会造成文件损坏；此时，应该检测并修复文件系统；建议，离线进行 ext系列文件系统的专用工具 12345678910e2fsck：check a linux ext2/ext3/ext4 file Systeme2fsck [OPTIONS] device -y：对所有问题自动回答为yes -f：即使文件系统处于clean状态，也要强制进行检测fsck： check and repair a linux file system -t fstype：指明文件系统类型 fsck -t ext4=fsck.ext4 -a：无需交互而自动修复所有错误 -r：交互式修复 swap文件系统linux上的交换分区必须使用独立的文件系统，且文件系统的system ID必须为82 创建swap设备 123mkswap [OPTIONS] device -L LABEL：指明卷标 -f：强制 fat32(vfat)：linux和windows都支持的文件系统mkfs.vfat device 文件系统的使用挂载：mount卸载：umount根文件系统外的其他文件系统要想能够呗访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”； 挂载点：mount_point,用于作为另一个文件系统的访问入口 事先存在 应该使用未被或不会被其他进程使用到的目录 挂载点下原有的文件将会被隐藏 mount命令12345678910111213141516171819202122232425mount [-fnrsvw] [-t vfstype] [-o options] device dir命令选项-r：readonly，只读挂载-w：read and write，读写挂载-n：默认情况下，设备挂载或卸载的操作会同步更新至/etc/mtab文件中； -n 用于禁止次特性-t vfstype：指明要挂载的设备上的文件系统的类型，多数情况下可省略，此时mount会通过blkid来判断要挂断的设备的文件系统类型-L LABEL：挂载时以卷标的方式指明设备mount -L LABEL dir-u UUID：挂载时以UUID的方式指明设备mount -U UUID dir-o options：挂载选项 sync/async：同步/异步操作 atime/noatime：文件或目录在被访问时是否更新其访问时间戳 diratime/nodiratime：目录在被访问时是否更新其访问时间戳 remount：重新挂载 acl：支持使用facl功能 mount -o acl device dir tune2fs -o acl device ro：只读 rw：读写 dev/nodev：此设备上是否允许创建设备文件 exec/noexec：是否允许允许此设备上的程序文件 user/nouser：是否允许普通用户挂载此文件系统 suid/nosuid：是否允许程序文件上的suid和sgid特殊权限生效 default：use default options：rw，suid，dev，exec，auto，nouser，async，and relatime 一个使用技巧：可以实现将目录绑定至另一个目录上，作为其临时访问入口 1mount --bind 源目录 目标目录 查看当前系统所有已挂载的设备123mountcat /etc/mtabcat /proc/mounts 挂载光盘1mount -r /dev/cdrom mount_options 光盘设备文件：/dev/cdrom，/dev/dvd 挂载U盘实现识别U盘的设备文件 挂载本地回环设备123456mount -o loop /PATH/TO/SOME_LOOP_FILE MOUNT_POINT### umount命令```bashumount device | dir 注意：正在被进程访问到的挂载点无法被卸载 查看被那些进程所占用 1234lsof MOUNT_POINTfuser -v MOUNT_POINT终止所有正在访问某挂载点的进程fuser -km MOUNT_POINT 交换分区的启用和禁用创建交换分区的命令：mkswap 启用swapon12swapon [OPTION] [DEVICE]-a :定义在/etc/fstab文件中的所有swap设备 禁用swapoff1swapoff DEVICE 设定除根文件系统以外的其他文件系统能够开机时自动挂载：/etc/fstab文件每行定义一个要挂载的文件系统及相关属性：6个字段 要挂载的设备 设备文件 LABEL UUID 伪文件系统：如sysfs，proc，tmpfs 挂载点 swap类型的设备挂载点伪swap 文件系统类型 挂载选项 defaults：使用默认挂载选项 如果要同时指明多个挂载选项，彼此间以逗号隔开；defaults，acl，noatime，noexec 转储频率 0：从不备份 1：每天备份 2：每隔一天备份 自检次序 0：从不自检 1：首先自检，通常只能是根文件系统可用1 2：次级自检 … mount -a ：可自动挂载定义在此文件中的所支持自动挂载的设备 df和dudf命令1234df [OPTION]...[FILE]... -l：仅显示本地文件的相关信息 -h：human-readable -i：显示Inode的使用状态而非blocks du命令123du [OPTION]...[FILE]... -s：summary -h：human-readable 补充当创建分区出现该报错时 123WARNING: Re-reading the partition table failed with error 16: Device or resource busy.The kernel still uses the old table. The new table will be used atthe next reboot or after you run partprobe(8) or kpartx(8) 重新读取分区表 1partprobe]]></content>
      <categories>
        <category>Linux系统管理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux系统特殊权限]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2FLinux%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[Linux系统上的特殊权限特殊权限：SUID，SGID，STICKY安全上下文 进程以某用户的身份运行；进程是发起此进程用户的代理，因此以此用户的身份和权限完成所有操作 权限匹配模型 判断进程的属主，是否为被访问的文件属主；如果是，则应用属主的权限，否则进入第2步 判断进程的属主，是否属于被访问的文件属组；如果是，则应用属组的权限，否则进入第3步 应用other的权限 SUID默认情况下：用户发起的进程，进程的属主是其发起者，因此，其以发起者的身份在运行SUID的功用：用户运行某程序时，如果此程序拥有SUID权限，那么程序运行为进程时，进程的属主不是发起者，而是程序文件自己的属主 管理文件的SUID权限1chmod u+|-s FILE... 展示位置：属主的执行权限位，如果属主原本有执行权限，显示为小写s，否则显示为大写S SGID功用：当目录属组有写权限，且有SGID权限时，那么所有属于此目录的属组，且以属组身份在此目录中新建文件或目录时，新文件的属组不是用户的基本租，而是此目录的属组 管理文件的SGID权限1chmod g+|-s FILE... 展示位置：属组的执行权限位，如果属组原本有执行权限，显示为小写s，否则显示为大写S Sticky功用：对于属组或全局可写的目录，组内的所有用户或系统上的所有用户对在此目录中都能创建新文件或删除又有的已有文件；如果为此类目录设置Sticky权限，则每个用户能创建新文件，且只能删除自己的文件。 管理文件的Sticky权限1chmod o+|-t FILE... 展示位置：其他用户的执行权限位，如果其他用户原本有执行权限，显示为小写t，否则显示为大写T 系统上的/tmp和/var/tmp目录默认均有sticky权限 管理权限的另一方式 suid sgid sticky 八进制权限 0 0 0 0 0 0 1 1 0 1 0 2 0 1 1 3 1 0 0 4 1 0 1 5 1 1 0 6 1 1 1 7 基于八进制方式赋权时，可用于默认的三位八进制数字左侧在加一位八进制数字 Faclfacl:file access control lists，访问控制列表 文件的额外赋权机制在原来的u，g，o之外，另一层让普通用户能控制赋权给另外的用户或组的赋权机制 getfacl命令12user:USERNAME:MODEgroup:FROUPNAME:MODE setfacl命令赋权给用户：setfacl -m u：USERNAME：MODE FILE… 1setfacl -m u:fedora:rw test 赋权给组：setfacl -m g:GROUPNAME:MODE FILE…撤销赋权：setfacl -x u:USERNAME FILE… ； setfacl -x g:GROUPNAME FILE…]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件查找命令]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[文件查找，在文件系统上查找符合条件的文件，实现工具locate，find locate依赖于事先构建好的索引库，该索引库系统自动实现（周期性任务），手动更新数据库（updatedb） 工作特性 查找速度快 模糊查找 非实时查找 locate命令1234locate [OPTION]...PATTERN... -b #只匹配路径中的基名 -c #统计出共有多少个符合条件的文件 -r #BRE 注意：索引构建过程需要遍历整个根文件系统，极消耗资源 find实时查找工具，通过遍历指定起始路径下文件系统层极结构完成文件查找 工作特性 查找速度略慢 精确查找 实时查找 ##用法 1find [OPTIONS] [查找起始路径] [查找条件] [处理动作] 查找起始路径：指定具体搜索目标起始路径；默认为当前目录 查找条件：指定的查找标准，可以根据文件名、大小、类型、从属关系、权限等等标准进行，默认为找出指定路径下的所有文件 处理动作：对符合查找条件的文件做出的操作，例如删除等操作，默认为输出至标准输出 查找条件表达式：选项和测试 测试 根据文件名查找** 1234-name "pattern"-iname "pattern"支持glob风格的通配符：*,?,[],[^]-regex pattern：基于正则表达式查找文件，匹配是整个路径，而非其名 根据文件从属关系查找 123456-user USERNAME ：查找属主指定用户的所有文件-group GRPNAME ：查找属组指定的GID的所有文件-uid UID：查找属主指定用户的所有文件-gid GID：查找属组指定的GID的所有文件-nouser 查找没有属主的文件-nogroup 查找没有属组的文件 根据文件的类型查找： 12345678-type TYPE:f ：普通文件d ：目录文件i ：符号链接文件b ：块设备文件c ：字符设备文件p ：管道文件s ：套接字文件 组合测试 与：-a，默认组合逻辑 或：-o 非：-not，! 根据文件的大小查找 size [+|-]#UNIT，常用单位k，M，G，#UNIT：（#-1，#）区间，-#UNIT：（0，#-1）区间，+#UNIT（#，无穷大） 根据时间戳查找以“天”为单位： -atime[+|-]# #：[#,#-1) -#:(#,0] +#:(无限大，#-1] -mtime -ctime以“分钟为单位” -amin -mmin -cmin 根据权限查找 -perm [/|-]mode mode：精确权限匹配 /mode：任何一类用户（u，g，o）的权限中的任何一位（r，w，x）符合条件即满足；9位权限之间存在“或”关系 -mode：每一类用户（u，g，o）的权限中的每一位（r，w，x）同时符合条件即满足；9位权限之间存在“与”关系 处理动作 -print：输出至标准输出；默认的动作； -ls：类似于对查找到的文件执行“ls -l”命令，输出文件的详细信息 -delete：删除查找到的文件 -fls /PATH/TO/SOMEFILE：把查找到的所有文件的长格式信息保存至指定文件中 -ok COMMAND {} ;：对查找到的每一个文件执行由COMMAND表示的命令，每次操作都由用户进行确认 -exec COMMAND {} ;：对查找到的每一个文件执行由COMMAND表示的命令 注意：find传递查找到的文件路径至后面的命令时，是先查找出所有符合条件的文件路径，并一次性传递给后面的命令；但是有些命令不能接受过长的阐述，此时命令执行会失败；另一种方式可规避此问题：find | xargs COMMAND]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vim编辑器]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2Fvim%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[vim编辑器文本编辑器，文本有纯文本、ASCII text、Unicode文本编辑种类 行编辑器：sed 全屏编辑器：nano，vi，vim vim模式化的编辑器基本模式：编辑模式，命令模式，输入模式，末行模式（内置的命令行接口） 打开文件123vim [OPTION]...[FILE...]+n #打开文件后，直接让光标处于第n行行首+/PATTERN #打开文件后，直接让光标处于第一个被PATTERN匹配到的行的行首 模式转换 编辑模式：默认模式 编辑模式–&gt;输入模式 i：insert，在光标处输入 a：append，在光标处后方输入 o：在光标所在处的下方打开一个新行 I：在光标所在行的行首输入 A：在光标所在行的行尾输入 O：在光标所在处的上方打开一个新行 输入模式–&gt;编辑模式 ESC 编辑模式–&gt;末行模式 ： 末行模式–&gt;编辑模式 ESC 关闭文件 ZZ：保存并退出 ：q 退出 ：q! 强制退出，不保存此前的操作 ：wq 保存并退出 ：x 保存并退出 ：w /PATH/TO/SOMEFILE 光标跳转字符间跳转：h（向左跳转），l（向右跳转），j（向下跳转），k（向上跳转） 单词间跳转：w（下一个单词的词首），e（当前或后一个单词的词尾），b（当前或前一个单词的词首） 行首行尾跳转 ^：跳转至行首的第一个非空白字符 0：跳转至行首 $：跳转至行尾 行间跳转 #G：跳转至由#指定的行 1G，gg：跳转至第一行 G：跳转至最后一行 句间跳转 ) ( 段间跳转 { } 翻屏 Ctrl+f：向文件尾部翻一屏 Ctrl+b：向文件首部翻一屏 Ctrl+d：向文件尾部翻半屏 Ctrl+u：向文件首部翻半屏 Enter：按行向后翻 vim的编辑命令 字符编辑 #x：删除光标所在处开始的#个字符 xp：交换光标所在处的字符与其后面字符的位置 替换命令 r：替换光标所在处的字符 rCHAR 删除命令 d：删除命令，可结合光标跳转字符，实现范围删除d$ d^ dw de db dd：删除光标所在行 粘贴命令 p：缓冲区中的内容如果为整行，则粘贴在当前光标所在行的下方；否则粘贴至当前光标所在处的后方 P：缓冲区中的内容如果为整行，则粘贴在当前光标所在行的上方；否则粘贴至当前光标所在处的前方 复制命令 y：复制工作行为相似于d命令 改变命令 c：编辑模式–&gt;输入模式，实现删除操作 用法同d 可视化模式 v：按字符选定 V：按行选定 结合命令：d，c，y 撤销(undo)操作 u：撤销此前的操作，默认可撤销最近50次操作，可结合数量 撤销此前的撤销操作 Ctrl+r 重复执行前一个编辑操作 . vim自带教程 ：vimtutor vim末行模式内建的命令行接口 地址定界 start_pos[,end_pos] #：特定的第#行，例如5即第五行 .：当前行 $：最后一行 #,#：指定行范围，左侧起始行，右侧结束行 #,+#：指定行范围，左侧为起始行绝对编号，右侧为相对左侧行号的偏移量，例如：3,+7 %：全文 /pattern/：光标所在处开始第一次被模式所匹配到的行 /pat1/,/pat2/：光标所在处开始第一个被pat1所匹配到的行，到第一个被pat2匹配到的行，中间的内容 可同编辑命令一同使用，实现编辑操作，d，y，c w /PATH/TO/SOMEFILE：将范围内的文本保存至指定的文件中 r /PATH/FROM/SOMEFILE：将指定的文件中的文本读取并插入至指定位置 查找 /PATTERN：从当前光标所在处向文件尾部查找能够被当前模式匹配到的所有字符串 ?PATTERN：从当前光标所在处想文件首部查找能够被当前模式匹配到的所有字符串 n：下一个，与命令方向相同 N：上一个，与命令方向相反 查找并替换 s：末行模式的命令；使用格式： s/要查找的内容/替换为的内容/修饰符 要查找的内容：可使用正则表达式 替换为的内容：不能使用正则表达式，但可以引用 如果“要查找的内容”部分在模式中使用分组符号：在“替换为的内容”中使用后向引用 直接引用查找模式匹配到的全部文本，使用&amp;符号 i：忽略大小写 g：全局替换 分隔符可以用别的非常用符号：s@@@，s### 示例12%s@\&lt;t\([[:alpha:]]\+\)\&gt;@T\1@g%s@\&lt;t[[:alpha:]]\+\&gt;@&amp;er@g vim的多文件功能123456789101112vim FILE1 FILE2 ...文件间切换:next 下一个:prev 上一个:first 第一个:last 最后一个退出所有文件:wqall 保存所有文件并退出:wall :qall 多窗口 -o：水平分割窗口 -O：垂直分割窗口 在窗口间切换：Ctrl+w，ARROW 单个文件也可以分割为多个窗口进行查看 Ctrl+w，s：水平分割窗口 Ctrl+w，v：垂直分割窗口 定制vim的工作特性在末行模式下的设定，仅对当前vim进程有效永久有效：全局 /etc/vimrc；个人用户~/.vimrc 行号 显示：set number，简写为set nu 取消显示：set nomber，简写set nonu 自动缩进 启用：set al 禁用：set noal 高亮搜索 启用：set hlsearch 禁用：set nohlsearch 语法高亮 启用：syntax on 禁用：syntax off 忽略字符大小写 启用：set lc 禁用：set nolc 获取帮助 :help :help subject bash脚本编程之算数运算 算数运算格式 let VAR=算数运算表达式 VAR=$[算数运算表达式] VAR=$((算数运算表达式)) VAR=$(expor $ARG1 $OP $ARG2) 注意：乘法符号在有些场景中需要使用转义符]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[shell脚本基础]]></title>
    <url>%2Fshell%E8%84%9A%E6%9C%AC%2Fshell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[bash特性及bash脚本编程初步bash的特性命令行展开：~,{} 命令别名：alias，unalias 命令历史：history 文件名通配：glob 快捷键：Ctrl+a，e，u，k，l 命令补全：$PATH 路径补全bash特性之：命令hash 缓存此前命令的查找结果：key-value（key：搜索键，value：值） 1234hash命令 hash：列出 hash -d COMMAND：删除 hash -r ：请客 bash的特性之：变量 程序：指令+数据 指令：由程序文件提供 数据：IO设备、文件、管道、变量程序：算法+数据结构变量名+指向的内存空间，变量赋值 name=value，name指向存储value的内存空间变量类型：存储格式、表示数据范围、参与的运算编程语言： 强类型变量 弱类型变量： bash把所有变量统统视作字符类型 bash中的变量无需事先声明，相当于把声明和赋值过程同时实现 声明：类型，变量名变量替换：把变量名出现的位置替换位其所指向的内存空间中的数据变量引用：${var_name},$var_name变量名：变量名只能包含数字、字母和下划线、而且不能以数字开头，见名知义，命名机制遵循某种法则 bash变量类型：本地变量：作用域范围仅为当前shell进程 环境变量：作用域为当前shell进程及其子进程 局部变量：作用域仅为某代码片段（函数上下文） 位置参数变量：当执行脚本的shell进程传递的参数 特殊变量：shell内置的有特殊功用的变量 $?： 0，成功；1-255，失败本地变量： 变量赋值：name-value 变量引用：${name}，$name “”：变量名会替换为其值 ‘’：变量名不会替换为其值 查看变量：set 撤销变量：unset name 环境变量变量赋值 exprot name=value name=value export name declare -x name=vlaue name=value declare -x name 变量引用：${name}，$name注：bash内嵌了许多环境变量（通常为全大写字符），用于定义bash的工作环境PAHT,HISTFILE,HISTSIZE,HISTCONTROL,SHELL,HOME,UID,PWD,OLDPWD查看环境变量：export，declare -x ，printenv，env撤销环境变量：unset name只读变量： declare -r name readonly name 注：只读变量无法重新赋值，并且不支持撤销，存活时间为当前shell进程的生命周期，随shell进程终止而终止 bash特性之多命令执行COMMAND1;COMMAND2;COMMAND3;….逻辑运算：运算数：真（true，yes，on，1）假（false，no，off，0）与：1 &amp;&amp; 1 = 11 &amp;&amp; 0 = 00 &amp;&amp; 1 = 00 &amp;&amp; 0 = 0或 1 || 1 = 11 || 0 = 10 || 1 = 10 || 0 = 0非 ！1 = 0！0 = 1 1COMMAND1 &amp;&amp; COMMAND2 COMMAND1为“假”，则COMMAND2不会再执行否则，COMMAND1为“真”，则COMMAND2必须执行 1COMMAND1 || COMMAND2 COMMAND1为“假”，则COMMAND2必须执行否则，COMMAND1为“真”，则COMMAND2不会再执行示例： id $username || useradd $username shell脚本编程编程语言的分类：根据运行方式编译运行：源代码-&gt;编译器（编译）-&gt;程序文件解释运行：源代码-&gt;运行时启动解释器，由解释器边解释边运行根据其编程过程中功能的实现是调用库还是调用外部的程序文件：shell脚本编程：利用系统上的命令及编程组件进行编程完整编程：利用库编程组件进行编程；编程模型：过程式编程语言，面向对象的编程语言程序=指令+数据过程式：以指令为中心来组织代码，数据是服务于代码；顺序执行选择执行循环执行对象式：以数据为中心来组织代码，围绕数据来组织指令；类（class）：实例化对象，methodshell脚本编程：过程式编程，解释运行，依赖于外部程序文件运行 1234567如何写shell脚本 脚本文件的第一行，顶格：给出shebang，解释器路径，用于指明解释执行当前脚本的解释器程序文件 常见的解释器： #!/bin/bash #!/usr/bin/python #!/usr/bin/perl shell脚本：命令的堆积；但很多命令不具有幂等性，需要用程序逻辑来判断运行条件是否满足，以避免其运行中发生错误；运行脚本： 赋予执行权限，并直接运行此程序文件： chmod +x file 直接运行解释器，将脚本以命令行参数传递给解释器程序 bash file 注：脚本中的空白行会被解释器忽略；脚本中，除了shebang，余下的所有以#开头的行，都会呗视作注释而被忽略；此即为注释行。shell叫的运行是通过运行一个子shell进程实现的 练习1、显示etc下面的所有p和P开头的文件和文件夹2、把var目录下的所有文件和文件加以大写显示出来3、创建临时文件夹/tmp/file.xxxx 123ls -d /etc/[pP]*ls -d /var/* | tr 'a-z' 'A-Z'mktemp /tmp/file.xxx bash的配置文件两类： profile类：为交互式登陆的shell提供配置bashrc类：非交互式登陆的shell进程提供配置登陆类型： 交互式登陆shell进程：直接通过某终端输入账号和密码后登录打开的shell进程使用su命令：su - USERNAME，或者使用 su -l USERNAME执行的登陆切换非交互式登陆shell进程su USERNAME执行的登陆切换图形界面下打开的终端运行脚本profile类： 全局：对所有用户都生效/etc/profile/etc/profild.d/用户个人:仅对当前用户有效 1~/.bash——profile bashrc类： 全局：/etc/bashrc用户个人： 1~/.bashrc 功用1、定义本地变量2、定义命令别名注：仅管理员可以修改全局配置文件 交互式登陆shell进程 1/etc/profile--&gt;/etc/profile.d/*--&gt;~/.bash_profile--&gt;~/.bashrc--&gt;/etc/bashrc 非交互式登陆shell进程 1~/.bashrc--&gt;/etc/bashrc--&gt;/etc/profile.d* 命令行中定义的特性，例如变量和别名作用域为当前shell进程的生命周期配置文件顶的特性，只对随后新启动的shell进程有效 让通过配置文件定义的特性立即生效： 通过命令行重复定义一次 让shell进程重读配置文件12~]# source /PATH/FROM/CONF_FILE~]# . /PATH/FROM?CONF_FILE 文本处理工具1234Linux文本处理三剑客grep：文本过滤工具（模式：pattern）工具sed：stream editor，流编辑器；文本编辑工具awk：Linux上的实现为gawk，文本报告生成器（格式化文本） 正则表达式：Regual，Expression，REGEXP由一类特殊字符及文本字符所编写的模式，其中有些字符不表示其字面意义，而是用于表示控制或通配的功能；分两类：基本正则表达式：BRE扩展正则表达式：ERE grep 作用：文本搜索工具，根据用户指定的“模式（过滤条件）”对目标文件逐行进行匹配检查，打印匹配到的行 模式：由正则表达式的元字符及文本字符所编写出的过滤条件 正则表达式引擎12345678910111213grep [OPTIONS] PATTERN [FILE...]grep [OPTIONS] [-e PATTERN | -f FILE] [FILE...]OPTIONS: --color=auto #对匹配到的文本着色后高亮显示 -i #ignorecase，忽略大小写 -o #仅显示匹配到的字符串本身 -v #显示不能被模式匹配到的内容 -E #支持使用扩展的正则表达式元字符 -q #静默模式，即不输出任何信息 -A N #after，后N行 -B N #before，前N行 -C N #context，前后各N行 基本正则表达式元字符123456789101112131415字符匹配： .：匹配任意字符 []：匹配指定范围内的任意单个字符 [^]：匹配指定范围外的任意单个字符 [:diglt:]、[:lower:]、[:upper:]、[:alpha:]、[:punct:]、[:space:]匹配次数：用在指定其出现的次数的字符后面，用于限制其签名字符出现的次数 *：匹配其前面的字符任意次；0,1，多次； 例如：grep &quot;x*y&quot; .*：匹配任意长度的任意字符 \?：匹配其前面的字符0次或1次：即其前面的字符是可有可无的 \+：匹配其前面的字符1次或多次；即其前面的字符要出现至少1次 \&#123;m\&#125;：匹配其前面字符m次 \&#123;m,n\&#125;：匹配其前面字符至少m次，至多n次； \&#123;0,n\&#125;：至多n次 \&#123;m,0\&#125;：至少m次 位置锚定 123456789^：行首锚定，用于模式的最左侧$：行尾锚定。用于模式的最右侧^PATTERNS：用于PATTERN来匹配整行^$：空白行^[[:space:]]*$：空行或包含空白字符的行单词：非特殊字符组成的连续字符（字符串）都称为单词\&lt;或\b：词首锚定，用于单词模式的左侧\&gt;或\b：词尾锚定，用于单词模式的右侧\&lt;PATTERN\&gt;：匹配完整单词 分组及引用 1\(\)：将一个或多个字符捆绑在一起当做一个整体进行处理 PS：分组括号中的模式匹配到的内容会被正则表达式引擎自动记录与内部的变量中，这些变量为： /1：模式从左侧起，第一个左括号以及与之匹配的右括号之间的模式所匹配到的字符 /2：模式从左侧起，第二个左括号以及与之匹配的右括号之间的模式所匹配到的字符 /3 … 1grep &quot;\(l..e\).*\1&quot; lovers.txt #对比前后是否一致 后向引用：引用前面的分组括号中的模式所匹配到的字符 egrep支持扩展的正则表达式实现类似于grep文本过滤功能：grep -E 扩展正则表达式的元字符 12345678910111213141516171819202122232425字符匹配.：任意单个字符[]：指定范围内的任意单个字符[^]:指定范围外的任意单个字符次数匹配*：任意次?：0次或1次，其前的字符是可有可无的+：其前字符至少1次&#123;m&#125;：其前的字符m次&#123;m,n&#125;：至少m次，至多n次&#123;0,n&#125;：至多n次&#123;m,&#125;：至少m次位置锚定^：行首锚定$：行尾锚定\&lt;或\b：词首锚定\&gt;或\b：词尾锚定分组及引用()：分组。括号内的模式匹配到的字符会被记录于正则表达式引擎的内部变量中后向引用：\1，\2，...或：a|b：a或者b； C|cat：C或cat； (c|C)at：cat或Cat； fgrep不支持正则表达式元字符当无需用到元字符去编写模式时，使fgrep必能更好 文本查看及处理工具wcword count,显示行数，单词数，字节数 1234wc [OPTION]...[FILE]...-l #显示行数-w #显示字数-c #显示字节数 cut截取某几个字段 123cut OPTION...[FILE]...-d CHAR #以指定的字符为分隔符-f FIELDS #挑选出的字段，列 n指定的字段，n-m指n到m字段，n,m指n和m字段 sort排序 12345678sort [OPTION]...[FILE]...-t CHAR #指定字段分隔符-k n #用于排序指定的字段-n #基于数值大小进行排序例：sort -t: -k3 -n /etc/passwd #表示冒号分隔符的第三个参数来排序-r #逆序排序-f #忽略字符大小写-u #重复的行只保留一份 uniq报告或移除重复的行 1234uniq [OPTION]...[INPUT[OUTPUT]]-c #显示每行的重复次数-u #仅显示未曾重复过的行-d #仅显示曾重复过的行 diff逐行对比两个文件的不同 123diff [OPTION]...FILESdiff /PATH/TO/OLDFILE /PATH/TO/NEWFILE &gt; /PAHT/TO/PATCH_FILE-u #使用unfied机制，即显示要修改的行的上下文，默认为3行 patch定向文件打补丁 12path [OPTIONS] -i /PATH/TO/PATCH_FILE /PATH/TO/OLDFILEpach /PATH/TO/OLDFILE &lt; /PATH/TO/PATCH_FILE]]></content>
      <categories>
        <category>shell脚本</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用户、组和权限管理]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2F%E7%94%A8%E6%88%B7%E3%80%81%E7%BB%84%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[/etc/passwd：用户的信息库 name:passwd:UID:GID:GECOS:directory:shellname：用户名password：可以是加密的密码，也可是占位符xUID：GID：用户所属的主组的ID号GECOS：注释信息directory：用户的家目录shell：用户的默认shell，登录时默认shell程序 /etc/shadow：用户密码 用户名：加密的密码：最近一次修改密码的时间：最短使用期限：最长使用期限：警告期段：过期期段：保留字段 /etc/group：组的信息库 group_name：password：GID：user_listuesr_list：该组的用户成员，以此组为附加组的用户的用户列表相关命令：useradd,userdel,usermod,passwd,groupadd,groupdel,groupmod,gpasswd,chage,chsh,id,su 添加组删除组命令1234groupadd [选项] group_name -g GID #设置GID，默认是上一个GID+1 -n new_name #修改组名groupdel [选项] GROUP 创建、删除用户useradd命令：添加用户12345678useradd [选项] username -u, --uid UID:指定UID -g, --gid GROUP：指定基本组ID，此组需要事先存在 -G, --groups GROUP1[,GROUP2,...[,GROUPN]]：指明用户所属的附加组，多个组之间用逗号分隔 -c, --comment COMMENT：指明注释信息 -d, --home HOME_DIR：指定的路径为用户的家目录，通过复制/etc/skel此目录并重命名实现，指定的家目录路径如果事先存在，则不会为用户复制环境配置文件 -s, --shell SHELL：指定用户的默认shell，可用的所有shell列表存储在/etc/shells文件中 -r, --system 创建系统用户 注：创建用户时的诸多默认设定配置文件为/etc/login.defs 123useradd -D：显示创建用户的默认配置useradd -D 选项 ：修改默认选项的值： # 修改的结果保存于/etc/default/useradd文件中； usermod命令：修改用户属性1234567891011usermod [选项] 登录 -u, --uid UID：修改用户的ID为此处指定的新UID -g, --gid GROUP：修改用户所属的基本组 -G, --groups GROUP1[,GROUP2,...[,GROUPN]]：修改用户所属的附加组，原来的附加组会被覆盖 -a, --append：与-G一同使用，用于为用户追加新的附加组 -c, --comment COMMENT：修改注释信息 -d, --home HOME_DIR：修改用户的家目录，用户文件不会移动到新目录 -m, --move-home：只能与-d一同使用，将原来家目录移动为新的家目录 -s, --shell：修改用户默认shell -L, --lock：锁定用户密码 -U, --unlock：解锁用户密码 userdel命令：删除用户12userdel [选项] 登录 -r： 删除用户时一并删除其家目录 passwd命令 passwd：修改用户自己的密码 passwd UESRNAME：修改指定用户的密码，但仅有root有此权限 12345678-l,-u #锁定和解锁用户-d #清除用户密码串-e DATE #过期期限，日期-i DAYS #非活动期限-n DAYS #密码的最短使用期限-x DAYS #密码的最长使用期限-w DAYS #警告期限--stdin # echo "PASSWORD" | passwd -stdin USERNAME gpasswd命令组密码文件：/etc/gshedow gpasswd [选项] group -a USERNAME：向组中添加用户 -d USERNAME：从组中移除用户 newgrp命令：临时切换指定的组为基本组newgrp [-] [group] -：会模拟用户重新登录以实现重新初始化其工作环境： chage命令：更改用户名密码过期信息chage [选项] 登录名 -d -E -W -m -M id命令：显示用户的真实有效ID12345id [option]...[user] -u #仅显示有效的UID -g #仅显示用户的基本组ID -G #仅显示用户所属的所有组的ID -n #显示名字而非ID su命令：switch user登录式切换：会通过读取目标用户的配置文件来重新初始化 su - USERNAME su -l USERNAME非登录式切换：不会读取目标用户的配置文件进行初始化 su USERNAME注意：管理员可无密码切换至其他任何用户 -c ‘COMMAND’ :仅以指定用户的身份运行此处指定的命令 其他命令：chsh，chfn，finger，whoami 命令总结：groupadd，groupmod，groupdel，useradd，usermod，userdel，passwd，gpasswd，newgrp，id，su 权限管理权限 r：readable，读 w：writable，写 x：excutable，执行 文件 * r：可获取文件数据 * w：可修改文件的数据 * x：可将此文件运行为进行 目录 * r：可使用ls命令获取其下的所有文件列表 * w：可修改此目录下的文件列表，即创建或删除文件 * x：可cd至此目录中，且可使用ls -l来获取所有文件的详细属性信息权限组合机制 — 000 0 –x 001 1 -w- 010 2 -wx 011 3 r– 100 4 r-x 101 5 rw- 110 6 rwx 111 7 权限管理命令chmod命令 chmod [OPTION]… MODE[,MODE]…FILE…三类用户：u（属主）g（属组）o（其他）a（所有） MODE表示法：赋权表示法：直接操作一类用户的所有权限位 u= g= o= a= 授权表示法：直接操作一类用户的一个权限位r，w，x u+，u- g+，g- o+，o- a+，a- chmod [OPTION] … OCTAL-MODE FILE… 八进制表示法 chmod [OPTION] … –reference=RFILE FILE…选项： -R，–recursive：递归修改 从属关系管理命令：chown，chgrp1.chown命令： chown [OPTION] … [OWNER][:[GROUP]] FILE … chown [OPTION] … –reference=RFILE FILE … 选项： -R：递归修改注：用户对目录有写权限，对目录下的文件没有写权限，则不能修改该文件，可以删除该文件只有ROOT可以修改文件的属组属主 umask：文件的权限反向掩码，遮罩码文件： 666-umask 目录： 777-umask注：之所以文件用666去减，表示文件默认不能拥有执行权限，如果减得的结果中有执行权限，则需要将其加1umask命令 umask：查看当前umask umask MASK ：设置umask注：此类设定仅对当前shell进程有效 install命令install - copy files and set attributes 单源复制 install [OPTION] ... [-T] SOURCE DEST 多源复制 install [OPTION] ... SOURCE ... DIRECTORY install [OPTION] ... -t DIRECTORY SOURCE ... 创建目录： install [OPTION] ... -d DIRECTORY 常用选项： -m，--mode=MODE：设定目标文件权限，默认为755： -o，--owner=OWMER：设定目标文件属主 -g，--group=GROUP：设定目标文件属组mktemp命令mktemp - create a temporary file or directory mktemp [OPTION] ... [TEMPLATE] 常用选项： -d：创建临时目录注意：mktemp将会创建的临时文件名直接返回，因此，可直接通过命令引用保存起来]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bash的基础特性]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2Fbash%E7%9A%84%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[bash的基础特性命令历史shell进程会在其会话中保存此前用户提交执行过的命令history定制history的功能，可通过环境变量实现： HISTSIZE：shell进程可保留的命令历史的条数 HISTFILE：持久保存命令历史的文件，家目录下的.bash_history文件 HISTFILESIZE：定义文件最多保存多少条命令 12345history -c #清空命令历史history -d offset #删除指定历史命令history -w #使用命令将内存命令，写入文件中history -r #把历史命令从内存文件中读到内存中history # #显示最近的#条命令 调用命令历史列表中的命令 !#：再一次执行历史列表的第#条命令 !!：再一次执行上一条命令 !STRING：再一次执行命令历史列表中最近一个以STRING开头的命令 注意：命令的重复执行有时候需要依赖于幂等性 调用上一条命令的最后一个参数： 快捷键：ESC 字符串：!$ 控制命令历史记录的方式：环境变量HISTCONTROL ignoredups：忽略重复的命令 ignorespace：忽略以空白字符开头的命令 ignoreboth：以上两者同时生效修改变量的值： NAME=’VALUE’ 命令补全功能shell程序在接收到用户执行命令的请求，分析完成之后，最左侧的字符串会被当做命令命令处理机制查找内部命令：根据PATH环境变量中设定的目录，自左而右逐个搜索目录下的文件名 目录管理类的命令mkdir创建目录 1234mkdir [options]...DIRECTORY...-p #自动按需创建父目录-v #verbose，显示详细过程-m #MODE：直接给定权限 命令行展开~：自动展开为用户的家目录，或指定的用户的家目录{}：可承载一个以逗号分隔的路径列表，并能够将其展开为多个路径例如：/tmp/{a,b}相当于、/tmp/a /tmp/b tree命令tree [option] directory -L level:指定要显示的层级 命令的执行状态结果 命令的执行状态结果，bash通过状态返回值来输出此结果： 成功：0 失败：1-255命令执行完成之后其状态返回值保存于bash的特殊变量$?中 注：命令正常执行时，有的返回有明朗返回值：根据命令及其功能不同，结果各不相同 引用命令的执行结果 12$(COMMAND) 或 `COMMAND`引用，强引用 '' 弱引用 "" 命令引用 `` 快捷键ctrl+a：跳转至命令行行首ctrl+e：跳转至命令行行尾ctrl+u：删除行首至光标所在处之间的所有字符ctrl+k：删除光标所在处至行尾的所有字符ctrl+l：清屏，相当于clear 文件查看类命令cat,tac,head,tail,more,lesshead命令 123head [options] FILE-n * #查看前n行-* #同上 tail命令 1234tail [options] FILE-n * #查看后n行-* #同上-f #查看文件尾部内容结束后不退出，跟随显示新增内容 stat命令显示文件或文件系统的状态 文件包含两类数据元数据：metadata，属性，特性数据：data，真实文件数据内容 stat所看到是数据就是元数据 1234567891011stat FILE File: ‘anaconda-ks.cfg’ Size: 1579 Blocks: 8 IO Block: 4096 regular fileDevice: fd00h/64768d Inode: 33583811 Links: 1Access: (0600/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root)Context: system_u:object_r:admin_home_t:s0Access: 2019-06-21 00:05:40.458988944 +0800 #最近访问Modify: 2019-06-21 00:05:40.461988944 +0800 #最近更改Change: 2019-06-21 00:05:40.461988944 +0800 #最近改动 Birth: - touch用来改变文件的时间戳 123456touch [options] FILE-a #修改access time-m #修改modify time-c #指定文件不存在时，不创建文件-t STAMP [[CC]YY]MMDDhhmm[.ss] #修改时间为指定时间touch -m -t 1906250000.00 FILE 注：touch不能修改Change time 文件管理工具cp,mv,rmcp命令 12cp -r SOURCE DEST #递归复制目录-d #复制符号链接文件本身，而非其指向的源文件 cp命令12345678910111213-i #交互式复制，即覆盖之前提醒用户确认-f #强制覆盖目标文件-r ，-R #递归复制目录-d #复制符号链接文件本身，而非其指向的源文件-a #-dR --preserve=all，archive，用于实现归档，保留源文件所有属性（备份）--preserv= mode #权限 ownership #属主和属组 timestamps #时间戳 context #安全标签 xattr #扩展属性 links #符号链接 all #上述所有属性 变量命名的内存空间变量类型 字符型 数值型 精确数值 近似数值 存储格式、数据范围、参与运算 变量赋值操作 name=tom globbing文件名通配注：整体文件名匹配，而非部分 匹配模式元字符 *：匹配任意长度的任意字符 pa*,*pa*,*pa,*p*a* ?：匹配任意单个字符 pa?,??pa,p?a,p?a? []：匹配指定范围内的任意单个字符 有几种特殊格式：[a-z],[A-Z],[0-9],[a-z0-9] [[:upper:]]：所有大写字母 [[:lower:]]：所有小写字母 [[:alpha:]]：所有字母 [[:digit:]]：所有数字 [[:alnum:]]：所有字母和数字 [[:space:]]：所有空白字符 [[:punct:]]：所有标点符号 [^]:匹配指定范围外的任意单个字符[^0-9],[^[:upper:]] 注：文件名通配时不区分大小写 IO重定向及管道程序的数据流有三种 输入的数据流：&lt;–标准输入（stdin），键盘 输出的数据流：–&gt;标准输出（stdout），显示器 错误输出流：–&gt;错误输出（stderr），显示器fd：file descriptor，文件描述符 标准输入：0 标准输出：1 错误输出：2IO重定向 覆盖输出重定向：&gt; 追加输出重定向：&gt;&gt; set -C #禁止覆盖输出重定向至已存在的文件，此时可使用强制覆盖输出：&gt;| set +C 关闭上述特性 输入重定向：&lt; tr命令 12345tr [options]...SET1[SET2] #把输入的数据当中的字符，凡是在SET1定义范围内出现的，通通对位转换为SET2出现的字符用法1：tr SET1 SET2 &lt; /PATH/FROM/SOMEFILE用法2：tr -d SET1 &lt; /PATH/FROM/SOMEFILE 管道链接程序，实现将前一个命令的输出直接定向后一个程序当做输入 tee把前一个命令的结果分为两个流，一个保存到文件中，一个送往后一个命令 12COMMAND | tee /PATH/TO/SOMEFILEcat passwd |tee ./clx.yum.log|tr [a-z] [A-Z]]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用命令12345678910111213pwd #显示工作目录cd #change directoryecho $PWD #当前工作目录环境变量echo $OLDPWD #上次的工作目录环境变量ls #列出指定目录下的内容ls -ld 目录 #查看目录自身属性cat -n #文本文件查看,-n表示给文本文件添加行编号tac #同上，但是逆序显示file #查看文件类型echo -e #让转义符生效，例如\n换行shutdown #关机 -h 关机 -r 重启shutdown -c #取消关机wall #向所有人的终端发送消息 ls -l结果 -rw-r–r– 1 root root 85374 Jun 23 19:06 dump.rdb -:文件类型，-，d，b，c，l，s，prw-：文件属主的权限r–：文件属组的权限r–：其他用户（非属主、属组）的权限1：表示硬链接次数root：文件属主root：文件属组85374：表示文件的大小，单位字节Jun 23 19:06：文件最后一次被修改的时间dump.rdb：文件名 文件类型-：常规文件，即fd：directory，目录文件b：block device，块设备文件，支持以“block”为单位进行随机访问c：character device，字符设备文件，支持以“character”为单位进行线性访问 major number：主设备号，用于识别设备类型，进而确定要加载的驱动程序 minor number：次设备号，用于标识同一类型中的不同的设备l：符号链接文件，类似快捷方式p：pipe，命名管道s：socket，套接字文件 echo [OPTION]…[STRING]…STRING可以使用引号，’’、””单引号：强引用，变量引用不执行替换双引号：弱引用，变量引用执行替换 日期相关的命令123456date [OPTION]... [+FORMAT] #显示时间 date +%F 显示日期 +%H 显示小时 +%T 显示准确时间 # Y年 m月 d日 H时 M分 S秒 s从1970.1.1日0点0分0秒到现在经过多少秒date [MMDDhhmm[[CC]YY][.ss]] #设定日期时间date 101008082013.08 #设定日期2013年10月10日8点8分8秒clock，hwclock #显示硬件时钟 -s 把硬件时间设置为系统时间 -w 把系统时间设置为硬件时间cal 2019 #日历指定月份年份 FHS:Filesystem Hierarchy Standard/bin：所有用户可用的基本命令程序文件 /sbin：供系统管理使用的工具程序 /boot：引导加载器必须用到的各静态文件：kernel，initramfs(initrd),grub等 /dev：存储特殊文件或设备文件：设备文件有两种类型：字符设备（线性设备）、块设备（随机设备） /etc：系统程序的配置文件，只能为静态 /home：普通用户的家目录的集中位置，一般每个普通用户的家目录默认为此目录下与用户名同名的子目录，/home/USERNAME /root：管理员的家目录 /lib：为系统启动或根文件系统上的应用程序（/bin,/sbin等）提供共享库，以及为内核提供内核模块 libc.so.*：动态链接C库 ld*：运行时链接器/加载器 modules：用于存储内核模块的目录 /lib64:64位系统特有的存放64位共享库路径 /media：便携式设备挂载点，cdrom，floppy等： /mnt：其它文件系统的临时挂载点 /opt：附加应用程序的安装位置：可选路径： /srv：当前主机为服务提供的数据 /tmp：为那些会产生临时文件的程序提供用于存储临时文件的目录，可供所有用户执行写入操作，有特殊权限 /usr：全局共享的只读数据路径 bin，sbin lib，lib64 /usr/local：让系统管理员安装本地软件 /var：存储经常发生变化的数据目录 /proc：内核及进程存储其相关信息，它们多为内核参数，例如net.ipv4.ip_forward,虚拟为net/ipv4/ip_forward,存储于/proc/sys/，因此其完整路径为/proc/sys/net/ipv4/ip_forward /sys：sysfs虚拟文件系统提供了一种比proc更为理想的访问内核数据的途径：其主要作用在于为管理Linux设备提供一种统一模型的接口基本命令命令类型外部命令内部命令 123type COMMAND #内部：builtin #外部：显示为命令文件路径 注意：命令可以有别名，别名可以与原名相同，此时原名被隐藏，此时如果要运行原命令，则使用\COMMAND 命令别名 123alias #获取所有可用别名的定义alias NAME='COMMAND' #定义别名unalias NAME #撤销别名 注意：仅对当前shell进程有效 which命令12wihick [options] programename --skip-alias:忽略别名 whereis命令123whereis [options] name -b:仅搜索二进制程序路径 -m：仅搜索使用手册文件路径 who命令123who [options] -b：系统此次启动的时间： -r：运行级别 who查看目前谁登陆了]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux基础（2）]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2Flinux%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[程序的组成部分：二进制程序文件、库文件、配置文件、帮助文件；二进制、库文件是可执行文件库文件不能单独执行，只能被调用时执行配置文件、帮助文件：可被查看其内容的文件 Linux基础知识命令的语法通用格式COMMAND OPTIONS ARGUMENTS例如 1ls -l /etc 命令本身也是可执行程序文件。多数系统程序文件都存放在：/bin,/sbin,/usr/bin,/usr/local/bin,/usr/local/sbin普通命令：/bin,/usr/bin,/usr/local/bin管理命令：/sbin,/usr/sbin,/usr/local/sbin 命令必须遵循特定格式规范：exe，msi，ELF（linux） 1file /bin/ls 环境变量PATH：查找该路径下是否有用户输入的命令 12echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:usr/lib64/erlang/bin:/usr/lib/rabbitmq/lib/rabbitmq_server-3.4.2/sbin:/root/bin type COMMEND：查看命令类型 获取命令使用帮助内部命令help COMMAND外部命令COMMAND --help使用手册：manualman COMMAND SYNOPSIS命令的options[]:可选内容 &lt;&gt;：必须提供的内容 a|b|c：多选一 ...：同类内容可出现多个 查看命令是否有手册 1whatis COMMAND 更新数据库 1makewhatis 翻屏`空格键：向文件尾翻一屏b：向文件首部翻一屏Ctrl+d：向文件尾部翻半屏Ctrl+u：向文件首部翻半屏回车：向文件尾部翻一行k：向文件首部翻一行G：跳转至最后一行 #G：跳转至指定行1G：跳转至文件首部` 文本搜索/keyword:从文件首部向文件尾部依次查找 ?keyword：从文件尾部向文件首部依次查找 n：下一个 N：上一个]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello Welcome]]></title>
    <url>%2Funcategorized%2F%E4%BD%A0%E5%A5%BD%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[linux基础（1）]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%80%2Flinux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、国内CentOS的镜像站点阿里镜像网易镜像搜狐镜像 二、远程连接1、SSH远程连接12345ss -tnl #查看SSH端口是否打开ip addr list #查看IP地址iptables -L -n #确认防火墙状态systemctl disable firewalld.service #关闭防火墙，重启生效systemctl stop firewalld.service #关闭防火墙，重启不生效 三、终端设备串行终端：ttyS伪终端：tty 查看终端设备和接口程序12ttyecho $SHELL 用户类型#：管理员账号$：普通用户 注意：建议使用非管理员账号登录 几个基础命令tty：查看当前的终端设备ip addr list：查看活动接口的IP地址echo：回显 1234basename /PATH/TO/SOMEFILESOMEFILEdirname /PATH/TO/SOMEFILE/PATH/TO linux的哲学思想： 一切皆文件 由众多功能单一的程序组成 尽量避免与用户交互 使用文本文件保存配置信息]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
</search>
